// PumpPortal API client for embedded token creation and trading
// https://pumpportal.fun - allows creating pump.fun tokens without leaving rpgcast.xyz

const PUMPPORTAL_API = 'https://pumpportal.fun/api';

export interface TokenMetadata {
  name: string;
  symbol: string;
  description: string;
  imageUrl?: string;
  twitter?: string;
  telegram?: string;
  website?: string;
}

export interface CreateTokenParams extends TokenMetadata {
  // Initial buy amount in SOL (optional, creates initial liquidity)
  initialBuyAmount?: number;
}

export interface CreateTokenResult {
  signature: string;
  mint: string;
  metadataUri: string;
}

export interface TradeParams {
  action: 'buy' | 'sell';
  mint: string;
  amount: number; // SOL for buy, tokens for sell
  denominatedInSol: boolean;
  slippage: number; // percentage (e.g., 10 for 10%)
  priorityFee?: number; // in SOL
}

export interface TradeResult {
  signature: string;
}

export interface TokenData {
  mint: string;
  name: string;
  symbol: string;
  description: string;
  imageUri: string;
  metadataUri: string;
  creator: string;
  createdTimestamp: number;
  complete: boolean; // bonding curve complete
  virtualSolReserves: number;
  virtualTokenReserves: number;
  marketCapSol: number;
  usdMarketCap?: number;
}

// Create a token on pump.fun via PumpPortal
// Returns transaction bytes for the user to sign
export async function createTokenTransaction(
  params: CreateTokenParams,
  creatorWallet: string
): Promise<{ transaction: Uint8Array; mint: string }> {
  // First, upload metadata to IPFS via PumpPortal
  const formData = new FormData();
  formData.append('name', params.name);
  formData.append('symbol', params.symbol);
  formData.append('description', params.description);
  if (params.twitter) formData.append('twitter', params.twitter);
  if (params.telegram) formData.append('telegram', params.telegram);
  if (params.website) formData.append('website', params.website);

  // If imageUrl is provided, fetch and include it
  if (params.imageUrl) {
    try {
      const imageRes = await fetch(params.imageUrl);
      const imageBlob = await imageRes.blob();
      formData.append('file', imageBlob, 'token-image.png');
    } catch (e) {
      console.warn('Could not fetch image, proceeding without');
    }
  }

  // Upload metadata and get IPFS URI
  const ipfsRes = await fetch(`${PUMPPORTAL_API}/ipfs`, {
    method: 'POST',
    body: formData,
  });

  if (!ipfsRes.ok) {
    throw new Error(`Failed to upload metadata: ${ipfsRes.statusText}`);
  }

  const { metadataUri } = await ipfsRes.json();

  // Generate a new mint keypair (done client-side for security)
  // The mint keypair is generated by the caller

  // Request transaction from PumpPortal
  const txRes = await fetch(`${PUMPPORTAL_API}/trade-local`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      publicKey: creatorWallet,
      action: 'create',
      tokenMetadata: {
        name: params.name,
        symbol: params.symbol,
        uri: metadataUri,
      },
      mint: '', // Will be filled by mint keypair
      denominatedInSol: 'true',
      amount: params.initialBuyAmount || 0,
      slippage: 10,
      priorityFee: 0.0005,
      pool: 'pump',
    }),
  });

  if (!txRes.ok) {
    throw new Error(`Failed to create transaction: ${txRes.statusText}`);
  }

  const txData = await txRes.arrayBuffer();
  return {
    transaction: new Uint8Array(txData),
    mint: '', // Caller provides the mint from their keypair
  };
}

// Create a buy/sell transaction
export async function createTradeTransaction(
  params: TradeParams,
  walletAddress: string
): Promise<Uint8Array> {
  const res = await fetch(`${PUMPPORTAL_API}/trade-local`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      publicKey: walletAddress,
      action: params.action,
      mint: params.mint,
      denominatedInSol: params.denominatedInSol ? 'true' : 'false',
      amount: params.amount,
      slippage: params.slippage,
      priorityFee: params.priorityFee || 0.0005,
      pool: 'pump',
    }),
  });

  if (!res.ok) {
    throw new Error(`Failed to create trade transaction: ${res.statusText}`);
  }

  return new Uint8Array(await res.arrayBuffer());
}

// Fetch token data from pump.fun API
export async function getTokenData(mint: string): Promise<TokenData | null> {
  try {
    const res = await fetch(`https://frontend-api.pump.fun/coins/${mint}`);
    if (!res.ok) return null;
    return await res.json();
  } catch {
    return null;
  }
}

// WebSocket connection for real-time updates
export function createPumpWebSocket(
  onNewToken?: (token: TokenData) => void,
  onTrade?: (trade: any) => void
): WebSocket {
  const ws = new WebSocket('wss://pumpportal.fun/api/data');

  ws.onopen = () => {
    // Subscribe to new token creations
    if (onNewToken) {
      ws.send(JSON.stringify({
        method: 'subscribeNewToken',
      }));
    }
  };

  ws.onmessage = (event) => {
    try {
      const data = JSON.parse(event.data);

      if (data.txType === 'create' && onNewToken) {
        onNewToken(data);
      } else if ((data.txType === 'buy' || data.txType === 'sell') && onTrade) {
        onTrade(data);
      }
    } catch (e) {
      console.error('WebSocket parse error:', e);
    }
  };

  return ws;
}

// Subscribe to trades for a specific token
export function subscribeToToken(ws: WebSocket, mint: string) {
  ws.send(JSON.stringify({
    method: 'subscribeTokenTrade',
    keys: [mint],
  }));
}

// Unsubscribe from a token
export function unsubscribeFromToken(ws: WebSocket, mint: string) {
  ws.send(JSON.stringify({
    method: 'unsubscribeTokenTrade',
    keys: [mint],
  }));
}
